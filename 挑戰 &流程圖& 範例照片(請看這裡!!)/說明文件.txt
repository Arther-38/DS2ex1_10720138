任務一 MaxHeap
一筆一筆讀取資料,讀取的資料插入vector的最後一位,每讀取一筆做向上的調整,如果父節點比自己小即與父節點進行交換,
最多做到根部的下一層

任務二 Deap
第一個節點(root)為空,之後的子節點分成兩個子樹,左半邊為minheap,右半邊為maxheap,且要符合deap對於兩邊對應節點大小
關係的要求,當插入節點在maxheap中時,先與對應節點比較,若比對應節點小即交換,此時插入節點在minheap並做最小堆積化,
而轉移到maxheap的節點可以被保證不需要調整,因在此對應節點在剛插入到樹中時，早就會與其對應節點的父節點交換。
若插入節點在minheap則對應節點必為對應之父節點,因heap是一種保證為完全樹的結構,之後的動作與在maxheap中相同。

任務三MinMax Heap
MinMaxHeap遵守第一層為minheap第二層maxheap第三層為minheap...的編排規則,也就是minheap和maxheap要各隔一層來看,若插入的節點在min層且剛插入節點的值
比父節點的值小則兩點交換,交換後的插入節點變成在max層,從minheap變成為maxheap的一員了,所以接下來換成要在maxheap做向上調整的動作,而其在maxheap中的
父節點其實是他所在位置的祖先(爺)節點,若比他的祖先節點大則交換,若沒有則留在自己原本的minheap中做一樣的調整交換動作。(反之插入的節點在max層的作法亦然)

平均時間效率實驗

	file|	003	104	105	
mission	    |
____________|	
    
任務一		0.008	0.0019	0.0084

任務二		0.0161	0.0033	0.0149	

任務三		0.0071	0.0018	0.007

心得
Heap堆積是比單純的二元樹更有效率的一個結構(新增與刪除),在最好狀況下只要插入在最後一位就行了
而不需要從根部開始比較,在實作中能熟悉一些重要的節點位置,例如: 最左下底部,父節點,爺、孫節點,
根部、最底部、層數,依其特性讓編程者在寫程式時可以使用陣列操作而可避免使用指標,此結構應用廣泛
,尤其是當討論到優先權時,使用堆積可以提高效率,而這次的minmaxheap和deap則是增強一般單權重的heap
,在雙權重模式下可以在一樣的時間複雜度下同時獲得最大與最小值,是非常經典的兩種堆積變形。

此次作業重新讓我複習了讀檔,物件導向以及藉由三個不同的heap種類實作,加之老師的教學影片和網上爬文
找相關寫法,讓我對heap的熟悉度增加許多。