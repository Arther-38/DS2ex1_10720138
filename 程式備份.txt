/**電資三 10720138 陳尚宏 DSex110720138 **/

#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include <cstring>
#include <sstream>
#include <cstdlib>
#include <ctime>
#include <time.h>
#include <math.h>

using namespace std;

typedef struct HeapNode
{

    string schNum,schName,majorNum,majorName,genre,DayNight,Edu,City;
    int sNum,tNum,gradu;

    HeapNode():schNum(""),schName(""),majorNum(""),majorName(""),genre(""),DayNight(""),Edu(""),City(""),sNum(-1),tNum(-1),gradu(-1) {};

    HeapNode(string a,string b,string c,string d,string e,string f,
             string g,string h,int i,int j,int k):schNum(a),schName(b),majorNum(c),majorName(d)
        ,genre(e),DayNight(f),Edu(g),City(h),sNum(i),tNum(j),gradu(k) {};

} Node;

/** Note

Apply array-based data structure to implement Heap

Fundamental Heap-related data structures implementation

Project list:
------------------
Max/Mini Heap: (f)
func: insert one by one
      delete

MinMaxHeap:
func: insert one by one
      delete

Double-ended Priority Queue (Deap): (f)
func: insert one by one
      delete

binomial heap
Fibonacci Heap

**/

class MaxHeap
{
private:
    vector<Node> Maxvec ;
public:

int my_split(const string& src, const char& delim,
             vector<string>& vec)
{
    int src_len = src.length();
    int find_cursor = 0;
    int read_cursor = 0;

    if (src_len <= 0)
        return -1;

    vec.clear();

    while (read_cursor < src_len)
    {

        find_cursor = src.find(delim, find_cursor);

        if (-1 == find_cursor)
        {
            if (read_cursor <= 0)
                return -1;

            if (read_cursor < src_len)
            {
                vec.push_back(src.substr(read_cursor, src_len - read_cursor));
                return 0;
            }
        }

        else if (find_cursor == read_cursor &&(read_cursor!=0))
            vec.push_back(string(""));

        else
            vec.push_back(src.substr(read_cursor, find_cursor - read_cursor));

        read_cursor = ++find_cursor;

        if (read_cursor == src_len)
        {

            vec.push_back(string(""));
            return 0;
        }
    }//end while()
}

bool readfile(string filename)
{
    filename="input"+filename+".txt";
    cout<<filename<<endl;
    ifstream fin(filename.c_str());

    if(!fin)
    {
        cout<<"read file failed!\n\n";
        return false;
    }

    string s;

    if(fin)
    {
        int count=0;

        for(int i=0; i<2; i++)
            getline(fin,s);

        while(getline(fin,s))
        {
            title=s;
            break;
        }

        vector<string> vecSrc;
        vector<string> vecSplit;

        while(getline(fin,s))
        {
            vecSrc.push_back(s);

            for (string src : vecSrc)
            {
                Node arr;
                vecSplit.clear();

                int iRet = my_split(src, '\t', vecSplit);

                arr.schNum=vecSplit[0];

                arr.schName=vecSplit[1];

                arr.majorNum=vecSplit[2];

                arr.majorName=vecSplit[3];

                arr.DayNight=vecSplit[4];

                arr.Edu=vecSplit[5];

                arr.sNum=atoi(vecSplit[6].c_str());

                arr.tNum=atoi(vecSplit[7].c_str());

                arr.gradu=atoi(vecSplit[8].c_str());

                arr.City=vecSplit[9];

                arr.genre=vecSplit[10];

                Maxvec.push_back(arr);
                adjust_up(bottom());

            }
            vecSrc.clear();
        }
    }
    return true;
}

    MaxHeap() {}

    string title;

    int Left(int i)
    {
        return (2*i+1);
    }

    int Right(int i)
    {
        return (2*i+2);
    }

    int Parent(int i)
    {
        return (i-1)/2;
    }

    int Size()
    {
        return Maxvec.size();
    }

    /*void deletef()
    {
        string num;
        int cur=atoi(searchf(num));
        Assign(Maxvec[cur],Maxvec[bottom]);
        Maxvec[bottom--]=0;
        if(bottom > 1){
            if(Maxvec[cur].gradu > Maxvec[Parent(cur)].gradu && cur>1)
                adjust_up(cur);
            else
                adjust_down(cur);
        }

    }//end delete

    int searchf(string num){

        int flag=0; // find init
        for(int i=0;i<Size()-1;i++){
            if(Maxvec[i].gradu==atoi(num))
            {
                flag=1;
                  break;
            }
        }

        if(flag==1)
            return i;
        else{
            cout<<"Data not found!!\n";
            return -1;
        }
    }//end search

    void modify(){

        string data;
        cout<<"Input data to modify: ";
        cin>>data;

        if(searchf(data)!=-1)
        {
            if(isMaxhp)
            int cur = searchf(data);

            Maxvec[cur].gradu=atoi(data);
            if(Maxvec[cur].gradu > Maxvec[Parent(cur)].gradu && cur>1)
                adjust_up(cur);
            else
                adjust_down(cur);
        }

    }

    bool isMaxhp(){

    }

    void adjust_down(){

    }*/

    void adjust_up(int cur)
    {
        while(cur>0)
        {
            if(Maxvec[cur].sNum <= Maxvec[Parent(cur)].sNum)
                break;
            else
                swap(Maxvec[cur],Maxvec[Parent(cur)]);
            cur=Parent(cur);
        }
    }

    int leftmost()
    {
        int i=0;
        while(((int)pow(2,i)) < Size()+1)
        {
            i++;
        }
        return (int)pow(2,i-1)-1;

    }

    int bottom()      //rightmost
    {
        return Maxvec.size()-1;
    }

    void ShowHeap()
    {
       /* for(int i=0; i<Maxvec.size(); i++)
            cout<<Maxvec[i].sNum<<"\t";*/

        cout<<"\nLeftmost index= "<<leftmost()<<endl;
        cout<<"leftmost= "<< Maxvec[leftmost()].sNum <<endl;
        cout<<"bottom= "<< Maxvec[bottom()].sNum <<endl;;
        cout<<endl;
    }

}; ///End class MaxHeap

class MinHeap
{
private:
    vector<Node> Minvec;

public:

int my_split(const string& src, const char& delim,
             vector<string>& vec)
{
    int src_len = src.length();
    int find_cursor = 0;
    int read_cursor = 0;

    if (src_len <= 0)
        return -1;

    vec.clear();

    while (read_cursor < src_len)
    {

        find_cursor = src.find(delim, find_cursor);

        if (-1 == find_cursor)
        {
            if (read_cursor <= 0)
                return -1;

            if (read_cursor < src_len)
            {
                vec.push_back(src.substr(read_cursor, src_len - read_cursor));
                return 0;
            }
        }

        else if (find_cursor == read_cursor &&(read_cursor!=0))
            vec.push_back(string(""));

        else
            vec.push_back(src.substr(read_cursor, find_cursor - read_cursor));

        read_cursor = ++find_cursor;

        if (read_cursor == src_len)
        {

            vec.push_back(string(""));
            return 0;
        }
    }//end while()
}

bool readfile(string filename)
{
    filename="input"+filename+".txt";
    cout<<filename<<endl;
    ifstream fin(filename.c_str());

    if(!fin)
    {
        cout<<"read file failed!\n\n";
        return false;
    }

    string s;

    if(fin)
    {
        int count=0;

        for(int i=0; i<2; i++)
            getline(fin,s);

        while(getline(fin,s))
        {
            title=s;
            break;
        }

        vector<string> vecSrc;
        vector<string> vecSplit;

        while(getline(fin,s))
        {
            vecSrc.push_back(s);

            for (string src : vecSrc)
            {
                Node arr;
                vecSplit.clear();

                int iRet = my_split(src, '\t', vecSplit);

                arr.schNum=vecSplit[0];

                arr.schName=vecSplit[1];

                arr.majorNum=vecSplit[2];

                arr.majorName=vecSplit[3];

                arr.DayNight=vecSplit[4];

                arr.Edu=vecSplit[5];

                arr.sNum=atoi(vecSplit[6].c_str());

                arr.tNum=atoi(vecSplit[7].c_str());

                arr.gradu=atoi(vecSplit[8].c_str());

                arr.City=vecSplit[9];

                arr.genre=vecSplit[10];

                Minvec.push_back(arr);
                adjust_up(bottom());

            }
            vecSrc.clear();
        }
    }
    return true;
}

    MinHeap() {}

    string title;

    int Left(int i)
    {
        return (2*i+1);
    }

    int Right(int i)
    {
        return (2*i+2);
    }

    int Parent(int i)
    {
        return (i-1)/2;
    }

    int Size()
    {
        return Minvec.size();
    }

    void adjust_up(int cur)
    {
        while(cur>0)
        {
            if(Minvec[cur].sNum >= Minvec[Parent(cur)].sNum)
                break;
            else
                swap(Minvec[cur],Minvec[Parent(cur)]);
            cur=Parent(cur);
        }
    }

    int leftmost()
    {
        int i=0;
        while(((int)pow(2,i)) < Size()+1)
        {
            i++;
        }
        return (int)pow(2,i-1)-1;

    }

    int bottom()      //rightmost
    {
        return Minvec.size()-1;
    }

    void ShowHeap()
    {
        /*for(int i=0; i<Minvec.size(); i++)
            cout<<Minvec[i].sNum<<"\t";*/

        cout<<"\nLeftmost index= "<<leftmost()<<endl;
        cout<<"leftmost= "<< Minvec[leftmost()].sNum <<endl;
        cout<<"bottom= "<< Minvec[bottom()].sNum <<endl;;
        cout<<endl;
    }
};///End class MinHeap
//void Huffman(){};

class MMHeap
{
private:
    vector<Node> MMvec;
public:

    int my_split(const string& src, const char& delim,
                 vector<string>& vec)
    {
        int src_len = src.length();
        int find_cursor = 0;
        int read_cursor = 0;

        if (src_len <= 0)
            return -1;

        vec.clear();

        while (read_cursor < src_len)
        {

            find_cursor = src.find(delim, find_cursor);

            if (-1 == find_cursor)
            {
                if (read_cursor <= 0)
                    return -1;

                if (read_cursor < src_len)
                {
                    vec.push_back(src.substr(read_cursor, src_len - read_cursor));
                    return 0;
                }
            }

            else if (find_cursor == read_cursor &&(read_cursor!=0))
                vec.push_back(string(""));

            else
                vec.push_back(src.substr(read_cursor, find_cursor - read_cursor));

            read_cursor = ++find_cursor;

            if (read_cursor == src_len)
            {

                vec.push_back(string(""));
                return 0;
            }
        }//end while()
    }

    bool readfile(string filename)
    {
        filename="input"+filename+".txt";
        cout<<filename<<endl;
        ifstream fin(filename.c_str());

        if(!fin)
        {
            cout<<"read file failed!\n\n";
            return false;
        }

        string s;

        if(fin)
        {
            int count=0;

            for(int i=0; i<2; i++)
                getline(fin,s);

            while(getline(fin,s))
            {
                title=s;
                break;
            }

            vector<string> vecSrc;
            vector<string> vecSplit;

            while(getline(fin,s))
            {
                vecSrc.push_back(s);

                for (string src : vecSrc)
                {
                    Node arr;
                    vecSplit.clear();

                    int iRet = my_split(src, '\t', vecSplit);

                    arr.schNum=vecSplit[0];

                    arr.schName=vecSplit[1];

                    arr.majorNum=vecSplit[2];

                    arr.majorName=vecSplit[3];

                    arr.DayNight=vecSplit[4];

                    arr.Edu=vecSplit[5];

                    arr.sNum=atoi(vecSplit[6].c_str());

                    arr.tNum=atoi(vecSplit[7].c_str());

                    arr.gradu=atoi(vecSplit[8].c_str());

                    arr.City=vecSplit[9];

                    arr.genre=vecSplit[10];

                    MMvec.push_back(arr);

                }
                vecSrc.clear();
            }
        }
        return true;
    }

    MMHeap() {}

    string title;


};///End MinMaxHeap

class Deap
{
private:
    vector<Node> Dvec;
public:

int my_split(const string& src, const char& delim,
             vector<string>& vec)
{
    int src_len = src.length();
    int find_cursor = 0;
    int read_cursor = 0;

    if (src_len <= 0)
        return -1;

    vec.clear();

    while (read_cursor < src_len)
    {

        find_cursor = src.find(delim, find_cursor);

        if (-1 == find_cursor)
        {
            if (read_cursor <= 0)
                return -1;

            if (read_cursor < src_len)
            {
                vec.push_back(src.substr(read_cursor, src_len - read_cursor));
                return 0;
            }
        }

        else if (find_cursor == read_cursor &&(read_cursor!=0))
            vec.push_back(string(""));

        else
            vec.push_back(src.substr(read_cursor, find_cursor - read_cursor));

        read_cursor = ++find_cursor;

        if (read_cursor == src_len)
        {

            vec.push_back(string(""));
            return 0;
        }
    }//end while()
}

bool readfile(string filename)
{
    Dvec.push_back(Node());
    filename="input"+filename+".txt";
    cout<<filename<<endl;
    ifstream fin(filename.c_str());

    if(!fin)
    {
        cout<<"read file failed!\n\n";
        return false;
    }

    string s;

    if(fin)
    {
        for(int i=0; i<2; i++)
            getline(fin,s);

        while(getline(fin,s))
        {
            title=s;
            break;
        }

        vector<string> vecSrc;
        vector<string> vecSplit;

        while(getline(fin,s))
        {
            vecSrc.push_back(s);

            for (string src : vecSrc)
            {
                Node arr;
                vecSplit.clear();

                int iRet = my_split(src, '\t', vecSplit);

                arr.schNum=vecSplit[0];

                arr.schName=vecSplit[1];

                arr.majorNum=vecSplit[2];

                arr.majorName=vecSplit[3];

                arr.DayNight=vecSplit[4];

                arr.Edu=vecSplit[5];

                arr.sNum=atoi(vecSplit[6].c_str());

                arr.tNum=atoi(vecSplit[7].c_str());

                arr.gradu=atoi(vecSplit[8].c_str());

                arr.City=vecSplit[9];

                arr.genre=vecSplit[10];

                Dvec.push_back(arr);
                Heapify();

            }
            vecSrc.clear();
        }
    }
    return true;
}

    Deap() {}

    string title;

    int Left(int i)
    {
        return (2*i+1);
    }

    int Right(int i)
    {
        return (2*i+2);
    }

    int Parent(int i)
    {
        return (i-1)/2;
    }

    int MinRoot()
    {
        return 1;
    }

    int MaxRoot()
    {
        return 2;
    }

    int Size()
    {
        return Dvec.size();
    }

    int bottom()      //rightmost
    {
        return Dvec.size()-1;
    }

    int Floor(int cur)
    {
        int f=log2(cur+1)+1;
        return f;
    }

    void Max_adjust_up(int cur)
    {
        while(cur>2)
        {
            if(Dvec[cur].sNum < Dvec[Parent(cur)].sNum)
                break;
            else
                swap(Dvec[cur],Dvec[Parent(cur)]);
            cur=Parent(cur);
        }

    }///End Max_adjust_up

    void Min_adjust_up(int cur)
    {
        while(cur>2)
        {
            if(Dvec[cur].sNum > Dvec[Parent(cur)].sNum )
                break;
            else
                swap(Dvec[cur],Dvec[Parent(cur)]);
            cur=Parent(cur);
        }

    }///End Min_adjust_up

    bool IsAtMax(int cur)
    {
        while( Parent(cur)!=0)
        {
            cur=Parent(cur);
        }

        if(cur == MaxRoot())
        {
            return true;
        }
        else
            return false;

    }///End IsAtMax

    bool IsAtMin(int cur)
    {
         while( Parent(cur)!=0)
        {
            cur=Parent(cur);
        }
        if(cur == MinRoot())
        {
            return true;
        }

        else
            return false;

    }///End IsAtMin

    int corr_find(int cur) ///correspond node
    {
        int floor = log2(cur+1)+1;
        int corr;

        if(IsAtMax(cur))
        {
             corr=cur-pow(2,floor-2);
        }

        if(IsAtMin(cur))
        {
            corr=cur+pow(2,floor-2);
            if(corr>Size()-1)
                corr=Parent(corr);
        }

        return corr;

    }///End Min_corr_find

    void Heapify()
    {

        if(IsAtMax(bottom()) && bottom()>1)
        {
            if(Dvec[bottom()].sNum < Dvec[corr_find(bottom())].sNum)
            {
                 swap(Dvec[bottom()],Dvec[corr_find(bottom())]);
                 Min_adjust_up(corr_find(bottom()));
            }

            else
            {
                Max_adjust_up(bottom());
            }

        }

        if(IsAtMin(bottom()) && bottom()>1)
        {
            if(Dvec[bottom()].sNum > Dvec[corr_find(bottom())].sNum)
            {
                 swap(Dvec[bottom()],Dvec[corr_find(bottom())]);
                 Max_adjust_up(corr_find(bottom()));
            }

            else
            {
                Min_adjust_up(bottom());
            }
        }

    } ///End Heapify

    int leftmost()
    {
        int i=0;
        while(((int)pow(2,i)) < Size()+1)
        {
            i++;
        }
        return (int)pow(2,i-1)-1;

    }

    void ShowHeap()
    {
        int floor=1;
        /*for(int i=1; i<Dvec.size(); i++)
        {
            cout<<Dvec[i].sNum<<"\t";
            if(Floor(i+1) != Floor(i))
                cout<<"\n";
        }*/

        cout<<"\n\nLeftmost index= "<<leftmost()<<endl;
        cout<<"leftmost= "<< Dvec[leftmost()].sNum <<endl;
        cout<<"bottom= "<< Dvec[bottom()].sNum <<endl;;

        cout<<endl;
    }

};///End Deap


class binoHeap{
private:
    vector<Node> Bvec;
public:

};

class FiboHeap{
private:
    vector<Node> Fibo;
public:


};

string chooseFile()
{
    string filename;
    cout<<"\nInput a file number ([0] Quit): ";
    cin>>filename;
    if(filename == "0")
       exit(0);
    return filename;
}

int main()
{
    cout<<"@ Author: 電資三 10720138 陳尚宏 \n"<<endl;
    int choice;

    MaxHeap Max;
    MinHeap Min;
    Deap D;
    MMHeap M;
    binoHeap bi;
    FiboHeap fi;

    while(1)
    {
        cout<<"**** Heap Construction *****\n"
        <<"* 0. QUIT                  *\n"
        <<"* 1. Build a max heap      *\n"
        <<"* 2. Build a min heap      *\n"
        <<"* 3. Build a DEAP          *\n"
        <<"* 4. Build a MinMaxHeap    *\n"
        <<"*************************************\n"
        <<"Input a choice(0, 1, 2, 3, 4): ";
        cin>>choice;

        switch(choice)
        {
            case 0:return 0;

            case 1: Max.readfile(chooseFile());
                    Max.ShowHeap();
                    break;

            case 2: Min.readfile(chooseFile());
                    Min.ShowHeap();
                    break;

            case 3: D.readfile(chooseFile());
                    D.ShowHeap();
                    break;

            case 4: M.readfile(chooseFile());
                    break;

            default:cout<<"Command does not exist!\n";
                    break;
        }

    }

}
